TASK I - KTHREAD JOINING
Four different test cases were used in the testing of the KThread class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user.

--------------------------------------------------------------------------------------------------------------------------------

selfTest1() simply tests if a thread is able join another ready thread. ThreadB, the joinee, should terminate first and display a
message before ThreadA, the joiner, can display a message.

The output we get is:
Running test case 1
ThreadB has started!
ThreadB has finished!

--------------------------------------------------------------------------------------------------------------------------------

selfTest2() ensures that joining a finished thread does not cause the joiner to sleep. The joining thread should immediately display
a message after the join attempt.

The output we get is:
Running test case 2
ThreadB has finished!
Joining ThreadB did nothing!

--------------------------------------------------------------------------------------------------------------------------------

selfTest3() ensures that a thread cannot join itself. The thread will display a message after the failed join attempt.

The output we get is:
Running test case 3
ThreadA is not sleeping! The self join failed.

--------------------------------------------------------------------------------------------------------------------------------

selfTest4() tests to see if cyclical joining fails as it should. ThreadA will join ThreadB, and then ThreadB will attempt to join
ThreadA and immediately display a message stating that the join failed.

The output we get is:
Running test case 4
Thread B is not sleeping! The cyclical join failed!

--------------------------------------------------------------------------------------------------------------------------------

TASK II - THE CONDITION2 CLASS
Four different test cases were used in the testing of the Condition2 class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user.

--------------------------------------------------------------------------------------------------------------------------------

selfTest1() tests the basic functionality of putting a thread to sleep through a condition variable and waking it. ThreadA sleeps, and 
is later woken by ThreadB.

The output we get is:
Running condition test case 1
ThreadA has the lock! Going to sleep.
ThreadB has the lock!
ThreadA is awake!

--------------------------------------------------------------------------------------------------------------------------------

selfTest2() tests having many sleeping threads and waking them all. Threads display a message whenever they acquire the lock. The 
expected order of threads having the lock is A, B, C, D, A, B, C, D.

The output we get is:
Running condition test case 2
ThreadA has the lock!
ThreadB has the lock!
ThreadC has the lock!
ThreadD has the lock!
ThreadA has the lock!
ThreadB has the lock!
ThreadC has the lock!
ThreadD has the lock!

--------------------------------------------------------------------------------------------------------------------------------

selfTest3() tests the case of trying to call wake() and wakeAll() when there are no threads sleeping on the condition. When ThreadA has 
the lock, it will attempt to call wake() and wakeAll() on an empty condition variable. ThreadB will then take the lock and display a 
message. This shows that nothing unusual was caused by waking an empty condition variable.

The output we get is:
Running condition test case 3
ThreadA has the lock! Trying to wake and wakeAll.
ThreadB has the lock! There was nothing to wake.

--------------------------------------------------------------------------------------------------------------------------------

selfTest4() tests the case of trying to call condition methods without the respective lock. ThreadA will first sleep with the lock.
When ThreadB becomes the current thread, it will not have the lock and attempt to sleep and wake ThreadA; both will fail. After, it will
acquire the lock and succesfully wake up ThreadA.

The output we get is:
Running condition test case 4
ThreadA has the lock!
ThreadB is the current thread!
ThreadB failed to sleep!
ThreadB failed to wake!
ThreadB now has the lock!
ThreadA is awake!

--------------------------------------------------------------------------------------------------------------------------------


TASK III - THE ALARM CLASS
Four different test cases were used in the testing of the alarm class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user, 
having input already preassigned to any necessary values.

--------------------------------------------------------------------------------------------------------------------------------

The first test case, selfTest1() test the alarm class against a singular thread to check wether it sleeps and/or wakes within 
expected parameters. It does this by checking if the time taken for the thread to wake is within excpected parameters given 
that the machine calls timerInterrupt around every ~500 ticks.

public static void selfTest1() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 1: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(750);
        // If the thread waits at least 750 ticks and wakes after the next call to timerInterrupt (within 1000 - 1500 ticks).
				if ((Machine.timer().getTime() >= (current + 750)) && (Machine.timer().getTime() < (current + 1500))){
					System.out.println("Case #1 Success!");
					}
				else 
					System.out.println("Case #1 Failure!");
				}
			};
		
		KThread ThreadA = new KThread(A);
		ThreadA.fork();
		ThreadA.join();
}

The test case should output the following for a successful run of the test case:
Running alarm test case 1: 
Case #1 Success!

The test case should output the following for a failed run of the test case:
Running alarm test case 1: 
Case #1 Failure!

When running the OS the first test case displayed the following, indicating a successful run of the test case:
Running alarm test case 1: 
Case #1 Success!

--------------------------------------------------------------------------------------------------------------------------------

The second test case tests the alarm class when given odd arguments such as a negatives or a zero. In this case the thread 
should wake immediately  or as soon as possible. We check if this holds true by checking if the time the thread spent waiting 
is within excpected parameters given that the machine calls timerInterrupt around every ~500 ticks.

public static void selfTest2() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 2: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(0);
				// The following If statements checks if the thread woke immediately /next timerInterrupt call.
				if (Machine.timer().getTime() <= (current + 500)){
					alarm.waitUntil(-42);
					if (Machine.timer().getTime() <= (current + 1000)){
						System.out.println("Case #2 Success!");
						}
					else 
						System.out.println("Case #2 Failure!");
					}
				else 
					System.out.println("Case #2 Failure!");
				}
			};
		
		KThread ThreadA = new KThread(A);
		ThreadA.fork();
		ThreadA.join();
	}
  
The test case should output the following for a successful run of the test case:
Running alarm test case 2:
Case #2 Success!

The test case should output the following for a failed run of the test case:
Running alarm test case 2:
Case #2 Failure!

When running the OS the second test case displayed the following indicating a successful run of the test case:
Running alarm test case 2:
Case #2 Success!

--------------------------------------------------------------------------------------------------------------------------------

The third test case tests the alarm class against multiple forks of the same thread to check whether they sleep and/or wake 
within expected parameters and are awoken in a correct order. It does this by outputting output ressembling an echo, 
in other words all messages should be followed by their counterpart in the fork of the thread resembling the effect of an echo.

		public static void selfTest3() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 3: ");
		
		//The thread should display hello, hello, stop copying me!, stop copying me!, Im Telling On You!!...
		Runnable A = new Runnable() {
			public void run() {
				alarm.waitUntil(750);
				System.out.println("Hello?");
				alarm.waitUntil(2500);
				System.out.println("Stop Copying Me!");
				alarm.waitUntil(7500);
				System.out.println("Im Telling On You!!");
			};
		};
		KThread ThreadA = new KThread(A);
		KThread ThreadB = new KThread(A);
		ThreadA.fork();
		ThreadB.fork();
		ThreadA.join();
		ThreadB.join();
}

The test case should output the following for a successful run of the test case, any other variation would be a failure:
Running alarm test case 3:
Hello?
Hello?
Stop Copying Me!
Stop Copying Me!
Im Telling On You!!
Im Telling On You!!

When running the OS the third test case displayed the following indicating a successful run of the test case:
Running alarm test case 3:
Hello?
Hello?
Stop Copying Me!
Stop Copying Me!
Im Telling On You!!
Im Telling On You!!

--------------------------------------------------------------------------------------------------------------------------------

The fourth test case, selfTest4() tests the alarm class against multiple threads to check whether they sleep and/or wake within 
expected parameters and are awoken in a correct order. It does this by checking if the time taken for the threads to wake is 
within expected parameter given that the machine calls timerInterrupt around every ~500 ticks and by ensuring all threads are 
awoken in correct order based on their wake time.

	public static void selfTest4() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 4: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(750);
				if ((Machine.timer().getTime() >= (current + 750)) && (Machine.timer().getTime() < (current + 1500))){
					System.out.println("Case #4: ThreadA Success!");
					}
				else {
					System.out.println("Case #4: ThreadA Failure!");
					}
				System.out.println("ThreadA: This Should Display First");
				}
			};
		
		Runnable B = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(2500);
				if ((Machine.timer().getTime() >= (current + 2500)) && (Machine.timer().getTime() < (current + 3000))){
					System.out.println("Case #4: ThreadB Success!");
					}
				else {
					System.out.println("Case #4: ThreadB Failure!");
					}
				System.out.println("ThreadB: This Should Display Last");
				}
			};
		
		Runnable C = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(1500);
				if ((Machine.timer().getTime() >= (current + 1500)) && (Machine.timer().getTime() < (current + 2000))){
					System.out.println("Case #4: ThreadC Success!");
					}
				else {
					System.out.println("Case #4: ThreadC Failure!");
					}
				System.out.println("ThreadC: This Should Display Second");
				}
			};
		
		KThread ThreadA = new KThread(A);
		KThread ThreadB = new KThread(B);
		KThread ThreadC = new KThread(C);
		ThreadA.fork();
		ThreadB.fork();
		ThreadC.fork();
		ThreadA.join();
		ThreadB.join();
		ThreadC.join();
	}
	
    
The test case should output the following for a successful run of the test case:
Running alarm test case 4:
Case #4: ThreadA Success!
ThreadA: This Should Display First
Case #4: ThreadC Success!
ThreadC: This Should Display Second
Case #4: ThreadB Success!
ThreadB: This Should Display Last

The test case may output multiple variations of the following for a failed run of the test case:
An "Case #4: ThreadA/B/C Failure!" Message.
OR an improper wake order of the waiting threads as seen via "ThreadA/B/C: This Should Display First/Second/Last".

When running the OS the third test case displayed the following indicating a successful run of the test case:
Running alarm test case 4:
Case #4: ThreadA Success!
ThreadA: This Should Display First
Case #4: ThreadC Success!
ThreadC: This Should Display Second
Case #4: ThreadB Success!
ThreadB: This Should Display Last

-------------------------------------------------------------------------------------------------------------------

TASK IV

In creating the communicator class, five test cases were created: selfTest1, selfTest2, selfTest3, selfTest4, and selfTest5. Each test
case is called by the ThreadedKernel selfTest method and calls all the self test methods in the communicator class respectively. The 
methods themselves do not require any kind of user input, as it was entered already for the purpose of simplicity. 

-------------------------------------------------------------------------------------------------------------------

The first test case, selfTest1(), test the ability to handle both a speaker and a listener while waiting to communicate. This is a 
small simulation of what could be happening throughout a basic live operation.  The beginning of the method will broadcast that it 
is starting the self test 1 of 5, and then will proceed to the next step. The speaker will ‘speak’ a word to the listener and be 
sent to sleep. Once the speaker’s word has been sent, the listener will listen for a ‘word’ sent by the speaker, and will respond 
to the speakers request for a response, and will print out the ‘word’ that has been spoken. In this case, the word will be the integer
value 5. Here is the layout of the test case method:

    /**
     * This test case will demonstrate the effects of the Communicator
     * class while having both a speaker and a communicator in the ready
     * queue.
     */
    public static void selfTest1(){ 
    	
		System.out.println("Running condition test case 1 of 5");
    	final Communicator communicator = new Communicator();	
		
    	Runnable A = new Runnable(){
    		
    		public void run(){
    			lock.acquire();
    			System.out.println("Speaker Thread speaks to listener. Awaiting Verification!");
    			communicator.speak(5);
    			speakerSending.sleep();
    			System.out.println("Yup! Speaker Thread has finished speaking.");
    			lock.release();
    		}
    	};
    	
    	Runnable B = new Runnable(){
    		public void run(){
    			lock.acquire();
    			System.out.println("Listener receiving word spoken by speaker. Please wait for verification.");
    			int x = communicator.listen();
    			listenerReceiving.sleep();
    			System.out.println("Listener received!!!! Is this your word?: " + x);
    			lock.release();
    		}
    	};
    	
    	KThread thread1 = new KThread(A);
    	KThread thread2 = new KThread(B);
		thread1.fork();
		thread2.fork();
		thread1.join();
		thread2.join();
    }	// End of TestCase 1.
-------------------------------------------------------------------------------------------------------------------

The second test case will demonstrate the effects of having one speaker and no listener, and is not meant to be terminated. For that 
case, it was removed from the actual test cases for that reason. The speaker will send a ‘word’, in this case 5, to the listener, and
go immediately to sleep. After this is completed, the listener will receive the ‘word’, and will go to sleep, since it will not 
confirm the word sent by the speaker. Here is the layout of the second test case:

    /**
     * This test case will demonstrate the effects of having one speaker and no
     * listener in the ready queue. This will be demonstrated in both ways for
     * one speaker with no listener, as well as one listener with no speaker in
     * the waiting queue. 
     */
    public static void selfTest2(){
    	System.out.println("Running communicator test case 2 of 5");
    		final Communicator communicator = new Communicator();	
		
    		Runnable A = new Runnable(){
    			public void run(){
    				lock.acquire();
    				System.out.println("Speaker Thread speaking to listener.");
    				communicator.speak(5);
    				speakerSending.sleep();
				System.out.println("Speaker Thread finished speaking, waiting on responce.");	
    				lock.release();				
    			}
    		};
    		
        	Runnable B = new Runnable(){
        		public void run(){
        			lock.acquire();
        			System.out.println("Listener receiving word spoken by speaker.");
        			int x = communicator.listen();
        			listenerReceiving.sleep();
        			//here would print "Done" if there was another thread in the queue.
        			lock.release();
        		}
        	};
    		
        	KThread thread1 = new KThread(A); //speaker
        	thread1.fork();
        	thread1.join();
        	  
    } //end of method. 
-------------------------------------------------------------------------------------------------------------------

Test case three is similar to the previous test case; however, the difference is that this test case is testing what happens when there
is multiple speaker threads, and no listener threads. When the first thread speaks to the listener, it will send a ‘word’ to the 
listener, and just like the previous case, the listener will listen and not respond. However, the difference between the two test cases
is that the third one will increment the counter of listeners waiting to be executed. Here is the layout of the method:

   /**
     * This will test the effects of having multiple speaker or listener threads,
     * and none of the other. Assuming 3 threads, they will respectively act upon
     * their duties, and will be added to a waiting list until there is a thread of
     * the respective origin.
     */
    public static void selfTest3(){
    	System.out.println("Running communicator test case 3 of 5");
		final Communicator communicator = new Communicator();	
	
		Runnable A = new Runnable(){
			public void run(){
				lock.acquire();
				System.out.println("Speaker Thread A speaking to listener.");
				communicator.speak(5);
				speakerSending.sleep();
				System.out.println("Speaker Thread A finished speaking, waiting on responce.");
				lock.release();				
			}
		};
		
		Runnable B = new Runnable(){
			public void run(){
				lock.acquire();
				System.out.println("Speaker Thread B speaking to listener.");
				communicator.speak(6);
				speakerSending.sleep();
				System.out.println("Speaker Thread B finished speaking, waiting on responce.");
				lock.release();				
			}
		};
		
		Runnable C = new Runnable(){
			public void run(){
				lock.acquire();
				System.out.println("Speaker Thread C speaking to listener.");
				communicator.speak(7);
				speakerSending.sleep();
				System.out.println("Speaker Thread C finished speaking, waiting on responce.");
				lock.release();				
			}
		};
    	
		KThread thread1 = new KThread(A); //speaker
		KThread thread2 = new KThread(B); //speaker
		KThread thread3 = new KThread(C); //speaker
    	thread1.fork();
    	thread2.fork();
    	thread3.fork();
    	thread1.join();
    	thread2.join();
    	thread3.join();
    }
-------------------------------------------------------------------------------------------------------------------

The next test case demonstrates the functionality of all the previous test cases. It demonstrates the ability to have a functional 
communicator class and the ability to have multiple threads waiting to be executed. Since the method is rather long, the layout will
not be demonstrated, but will rather be available in the actual communicator class under testCase4(). 

-------------------------------------------------------------------------------------------------------------------

The fifth and final test case is demonstrating a live demonstration of what is a possible outcome in a real world test scenario. This
method will  have an equal number of speakers and listener, and will alternate have a different order in which the methods are called 
in. For example, the method will call the speaker twice, and the listener will be called three times after that. Similarity to the 
previous test case, since the method itself is very long, the layout will not be included, but is rather accessible in the communicator
class itself in the selfTest5() method. 

-------------------------------------------------------------------------------------------------------------------

TASK V
----------------------------------------------------------------------------------------------------------------------------------------
Four different test cases were used in the testing of the ReactWater class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user.
For all test cases, threads are destined to be one of two options: either a hydrogen or an oxygen atom as follows:
Here Runnable H is a hydrogen atom and O is an oxygen. They print which type they are and announce ready status. 
In the interest of saving some space, the Runnable declarations, forks and joins won't be repeated at each test case.
		Runnable H = new Runnable(){
			public void run(){
				System.out.println("Hydrogen is about to be prepared!");
				reactWater.hReady();
			}
		};
		Runnable O = new Runnable(){
			public void run(){
				System.out.println("Oxygen is about to be prepared!");
				reactWater.oReady();
			}
		};
	Next threads are created with one of the Runnable options.
		KThread thread1 = new KThread(H);
		KThread thread2 = new KThread(O);
	Here the threads are forked from the kernel.
		thread1.fork();
		thread2.fork();
	Finally, the threads can be joined for testing.
		thread1.join();
		thread2.join();
		
Test case 1:
	This test case is demonstrative of any amount of atoms where no group of 2 hydrogens and 1 oxygen can be made. 
	The above code is the code for this first case. In it, there are insufficient atoms to make water, so they wait 
	indefinitely for more threads that aren't coming.
	It would give: 
		Start of test case 1:
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
	Hydrogen and oxygen have no final hydrogen to make water, so they wait indefinitely.
		
Test case 2:
	This case demontrates the results of exactly the right amount of atoms to make one water. One hydrogen is created 
	and it waits. One oxygen is created and it waits. The next hydrogen provides sufficient total atoms to create a 
	water and so this is done. Since there are no more waiting threads nor any more threads to be created, the machine exits.
		KThread thread1 = new KThread(H);
		KThread thread2 = new KThread(O);
		KThread thread3 = new KThread(H);
	gives:
		Start of test case 2:
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		End of test case 2.
		Machine halting!

Test case 3:
	This test case will demonstrate the effect of having abundant atoms. The effect will be: threads are added to the 
	ready queue until sufficient atoms for makeWater exist, makeWater will be called returning 2 hydrogen and 1 oxygen 
	leaving any extra atoms as sleeping threads. This effect will continue until all water that can be made is made. 
	Either all threads will be returned or remaining upaired atoms will wait indefinitely. In this case, there will be 
	an unpaired oxygen left over.
		KThread thread1 = new KThread(H);
		KThread thread2 = new KThread(O);
		KThread thread3 = new KThread(H);
		KThread thread4 = new KThread(O);
		KThread thread5 = new KThread(O);
		KThread thread6 = new KThread(H);
		KThread thread7 = new KThread(H);
		KThread thread8 = new KThread(O);
		KThread thread9 = new KThread(H);
		KThread thread10 = new KThread(H);
		KThread thread11 = new KThread(O);
		KThread thread12 = new KThread(H);
		KThread thread13 = new KThread(H);
		KThread thread14 = new KThread(O);
		KThread thread15 = new KThread(H);
		KThread thread16 = new KThread(H);
	gives:
		Start of test case 3:
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Oxygen is about to be prepared!
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
	The 6th oxygen was not used in any water making, and so will wait indefinitely for more threads that are never coming.

Test case 4:
	Very similar premise to test case 3, except that there are a number of atoms that can pair into water without any 
	left over. In this case, all atoms can be paired and the machine can exit.
	    	KThread thread1 = new KThread(H);
		KThread thread2 = new KThread(H);
		KThread thread3 = new KThread(H);
		KThread thread4 = new KThread(O);
		KThread thread5 = new KThread(O);
		KThread thread6 = new KThread(H);
		KThread thread7 = new KThread(H);
		KThread thread8 = new KThread(O);
		KThread thread9 = new KThread(H);
		KThread thread10 = new KThread(H);
		KThread thread11 = new KThread(O);
		KThread thread12 = new KThread(H);
		KThread thread13 = new KThread(H);
		KThread thread14 = new KThread(O);
		KThread thread15 = new KThread(H);
	gives: 
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Oxygen is about to be prepared!
		Hydrogen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Hydrogen is about to be prepared!
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		Hydrogen is about to be prepared!
		Oxygen is about to be prepared!
		Enough atoms for water to be made. - Water was made.
		End of test case 4.
		Machine halting!
	Since all atoms can be paired up, there are no threads left waiting and the machine can exit.
