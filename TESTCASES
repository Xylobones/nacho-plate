TASK I - KTHREAD JOINING
Four different test cases were used in the testing of the alarm class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user.

--------------------------------------------------------------------------------------------------------------------------------

selfTest1() simply tests if a thread is able join another ready thread. ThreadB, the joinee, should terminate first and display a
message before ThreadA, the joiner, can display a message.

The output we get is:
Running test case 1
ThreadB has started!
ThreadB has finished!

--------------------------------------------------------------------------------------------------------------------------------

selfTest2() ensures that joining a finished thread does not cause the joiner to sleep. The joining thread should immediately display
a message after the join attempt.

The output we get is:
Running test case 2
ThreadB has finished!
Joining ThreadB did nothing!

--------------------------------------------------------------------------------------------------------------------------------

selfTest3() ensures that a thread cannot join itself. The thread will display a message after the failed join attempt.

The output we get is:
Running test case 3
ThreadA is not sleeping! The self join failed.

--------------------------------------------------------------------------------------------------------------------------------

selfTest4() tests to see if cyclical joining fails as it should. ThreadA will join ThreadB, and then ThreadB will attempt to join
ThreadA and immediately display a message stating that the join failed.

The output we get is:
Running test case 4
Thread B is not sleeping! The cyclical join failed!

--------------------------------------------------------------------------------------------------------------------------------

TASK II - THE CONDITION2 CLASS
Four different test cases were used in the testing of the alarm class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user.

--------------------------------------------------------------------------------------------------------------------------------

selfTest1() tests the basic functionality of putting a thread to sleep through a condition variable and waking it. ThreadA sleeps, and 
is later woken by ThreadB.

The output we get is:
Running condition test case 1
ThreadA has the lock! Going to sleep.
ThreadB has the lock!
ThreadA is awake!

--------------------------------------------------------------------------------------------------------------------------------

selfTest2() tests having many sleeping threads and waking them all. Threads display a message whenever they acquire the lock. The 
expected order of threads having the lock is A, B, C, D, A, B, C, D.

The output we get is:
Running condition test case 2
ThreadA has the lock!
ThreadB has the lock!
ThreadC has the lock!
ThreadD has the lock!
ThreadA has the lock!
ThreadB has the lock!
ThreadC has the lock!
ThreadD has the lock!

--------------------------------------------------------------------------------------------------------------------------------

selfTest3() tests the case of trying to call wake() and wakeAll() when there are no threads sleeping on the condition. When ThreadA has 
the lock, it will attempt to call wake() and wakeAll() on an empty condition variable. ThreadB will then take the lock and display a 
message. This shows that nothing unusual was caused by waking an empty condition variable.

The output we get is:
Running condition test case 3
ThreadA has the lock! Trying to wake and wakeAll.
ThreadB has the lock! There was nothing to wake.

--------------------------------------------------------------------------------------------------------------------------------

selfTest4() tests the case of trying to call condition methods without the respective lock. ThreadA will first sleep with the lock.
When ThreadB becomes the current thread, it will not have the lock and attempt to sleep and wake ThreadA; both will fail. After, it will
acquire the lock and succesfully wake up ThreadA.

The output we get is:
Running condition test case 4
ThreadA has the lock!
ThreadB is the current thread!
ThreadB failed to sleep!
ThreadB failed to wake!
ThreadB now has the lock!
ThreadA is awake!

--------------------------------------------------------------------------------------------------------------------------------


TASK III - THE ALARM CLASS
Four different test cases were used in the testing of the alarm class; selfTest1, selfTest2, selfTest3 and selfTest4. 
Each of these test cases are called via ThreadedKernal selfTest method and requires no input from the user, 
having input already preassigned to any necessary values.

--------------------------------------------------------------------------------------------------------------------------------

The first test case, selfTest1() test the alarm class against a singular thread to check wether it sleeps and/or wakes within 
expected parameters. It does this by checking if the time taken for the thread to wake is within excpected parameters given 
that the machine calls timerInterrupt around every ~500 ticks.

public static void selfTest1() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 1: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(750);
        // If the threadd waits at least 750 ticks and wakes after the next call to timerInterrupt (within 1000 - 1500 ticks).
				if ((Machine.timer().getTime() >= (current + 750)) && (Machine.timer().getTime() < (current + 1500))){
					System.out.println("Case #1 Success!");
					}
				else 
					System.out.println("Case #1 Failure!");
				}
			};
		
		KThread ThreadA = new KThread(A);
		ThreadA.fork();
		ThreadA.join();
}

The test case should output the following for a successful run of the test case:
Running alarm test case 1: 
Case #1 Success!

The test case should output the following for a failed run of the test case:
Running alarm test case 1: 
Case #1 Failure!

When running the OS the first test case displayed the following, indicating a successful run of the test case:
Running alarm test case 1: 
Case #1 Success!

--------------------------------------------------------------------------------------------------------------------------------

The second test case tests the alarm class when given odd arguments such as a negatives or a zero. In this case the thread 
should wake immediately  or as soon as possible. We check if this holds true by checking if the time the thread spent waiting 
is within excpected parameters given that the machine calls timerInterrupt around every ~500 ticks.

public static void selfTest2() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 2: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(0);
				// The following If statements checks if the thread woke immediately /next timerInterrupt call.
				if (Machine.timer().getTime() <= (current + 500)){
					alarm.waitUntil(-42);
					if (Machine.timer().getTime() <= (current + 1000)){
						System.out.println("Case #2 Success!");
						}
					else 
						System.out.println("Case #2 Failure!");
					}
				else 
					System.out.println("Case #2 Failure!");
				}
			};
		
		KThread ThreadA = new KThread(A);
		ThreadA.fork();
		ThreadA.join();
	}
  
The test case should output the following for a successful run of the test case:
Running alarm test case 2:
Case #2 Success!

The test case should output the following for a failed run of the test case:
Running alarm test case 2:
Case #2 Failure!

When running the OS the second test case displayed the following indicating a successful run of the test case:
Running alarm test case 2:
Case #2 Success!

--------------------------------------------------------------------------------------------------------------------------------

The third test case, selfTest1() tests the alarm class against multiple threads to check whether they sleep and/or wake within 
expected parameters and are awoken in a correct order. It does this by checking if the time taken for the threads to wake is 
within expected parameter given that the machine calls timerInterrupt around every ~500 ticks and by ensuring all threads are 
awoken in correct order based on their wake time.

	public static void selfTest3() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 3: ");
		
		Runnable A = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(750);
				if ((Machine.timer().getTime() >= (current + 750)) && (Machine.timer().getTime() < (current + 1500))){
					System.out.println("Case #3: ThreadA Success!");
					}
				else {
					System.out.println("Case #3: ThreadA Failure!");
					}
				System.out.println("ThreadA: This Should Display First");
				}
			};
		
		Runnable B = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(2500);
				if ((Machine.timer().getTime() >= (current + 2500)) && (Machine.timer().getTime() < (current + 3000))){
					System.out.println("Case #3: ThreadB Success!");
					}
				else {
					System.out.println("Case #3: ThreadB Failure!");
					}
				System.out.println("ThreadB: This Should Display Last");
				}
			};
		
		Runnable C = new Runnable() {
			public void run() {
				long current = Machine.timer().getTime();
				alarm.waitUntil(1500);
				if ((Machine.timer().getTime() >= (current + 1500)) && (Machine.timer().getTime() < (current + 2000))){
					System.out.println("Case #3: ThreadC Success!");
					}
				else {
					System.out.println("Case #3: ThreadC Failure!");
					}
				System.out.println("ThreadC: This Should Display Second");
				}
			};
		
		KThread ThreadA = new KThread(A);
		KThread ThreadB = new KThread(B);
		KThread ThreadC = new KThread(C);
		ThreadA.fork();
		ThreadB.fork();
		ThreadC.fork();
		ThreadA.join();
		ThreadB.join();
		ThreadC.join();
	}
	
    
The test case should output the following for a successful run of the test case:
Running alarm test case 3:
Case #3: ThreadA Success!
ThreadA: This Should Display First
Case #3: ThreadC Success!
ThreadC: This Should Display Second
Case #3: ThreadB Success!
ThreadB: This Should Display Last

The test case may output multiple variations of the following for a failed run of the test case:
An "Case #3: ThreadA/B/C Failure!" Message.
OR an improper wake order of the waiting threads as seen via "ThreadA/B/C: This Should Display First/Second/Last".

When running the OS the third test case displayed the following indicating a successful run of the test case:
Running alarm test case 3:
Case #3: ThreadA Success!
ThreadA: This Should Display First
Case #3: ThreadC Success!
ThreadC: This Should Display Second
Case #3: ThreadB Success!
ThreadB: This Should Display Last

--------------------------------------------------------------------------------------------------------------------------------

The fourth test case tests the alarm class against multiple forks of the same thread to check whether they sleep and/or wake 
within expected parameters and are awoken in a correct order. It does this by outputting output ressembling an echo, 
in other words all messages should be followed by their counterpart in the fork of the thread resembling the effect of an echo.

		public static void selfTest4() {
		Alarm alarm = new Alarm();
		System.out.println("Running alarm test case 4: ");
		
		//The thread should display hello, hello, stop copying me!, stop copying me!, Im Telling On You!!...
		Runnable A = new Runnable() {
			public void run() {
				alarm.waitUntil(750);
				System.out.println("Hello?");
				alarm.waitUntil(2500);
				System.out.println("Stop Copying Me!");
				alarm.waitUntil(7500);
				System.out.println("Im Telling On You!!");
			};
		};
		KThread ThreadA = new KThread(A);
		KThread ThreadB = new KThread(A);
		ThreadA.fork();
		ThreadB.fork();
		ThreadA.join();
}

The test case should output the following for a successful run of the test case, any other variation would be a failure:
Running alarm test case 4:
Hello?
Hello?
Stop Copying Me!
Stop Copying Me!
Im Telling On You!!
Im Telling On You!!

When running the OS the third test case displayed the following indicating a successful run of the test case:
Running alarm test case 4:
Hello?
Hello?
Stop Copying Me!
Stop Copying Me!
Im Telling On You!!
Im Telling On You!!

TASK IV

TASK V
